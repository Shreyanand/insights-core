from .. import Mapper, mapper, get_active_lines


@mapper("iptables")
class IPTables(Mapper):
    """
    Input Example:
    ----------------------------------------------------------------
    # Generated by iptables-save v1.4.7 on Tue Aug 16 10:18:43 2016
    *filter
    :INPUT ACCEPT [0:0]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [769:196899]
    :REJECT-LOG - [0:0]
    -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
    -A INPUT -s 192.168.0.0/24 -j ACCEPT
    -A INPUT -p icmp -j ACCEPT
    -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
    -A INPUT -j REJECT --reject-with icmp-host-prohibited
    -A REJECT-LOG -p tcp -j REJECT --reject-with tcp-reset
    COMMIT
    # Completed on Tue Aug 16 10:18:43 2016
    # Generated by iptables-save v1.4.7 on Tue Aug 16 10:18:43 2016
    *mangle
    :PREROUTING ACCEPT [451:22060]
    :INPUT ACCEPT [451:22060]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [594:47151]
    :POSTROUTING ACCEPT [594:47151]
    COMMIT
    # Completed on Tue Aug 16 10:18:43 2016
    # Generated by iptables-save v1.4.7 on Tue Aug 16 10:18:43 2016
    *nat
    :PREROUTING ACCEPT [0:0]
    :POSTROUTING ACCEPT [3:450]
    :OUTPUT ACCEPT [3:450]
    COMMIT
    # Completed on Tue Aug 16 10:18:43 2016

    PS:
       - Each table of iptables starting with a "# Generated by ..."
       - Each table is marked like *<table-name>, for example *filter
       - Each chain specifications starting with a ":" sign
       - A chain specification looks like :<chain-name> <chain-policy>
            [<packet-counter>:<byte-counter>]
       - The chain-name may be for example "INPUT"
       - Each iptables rule starting with a "-" sign
    ----------------------------------------------------------------

    Parse results:
    {
        "rules": [
            {
                "target": "REJECT",
                "chain": "REJECT-LOG",
                "rule": "-p tcp -j REJECT --reject-with tcp-reset",
                "table": "filter",
                "target_options": "--reject-with tcp-reset",
                "target_action": "jump",
                "constraints": "-p tcp"
            },
            ...
        ],
        "chains": [
            {
                "policy": null,
                "table": "filter",
                "byte_counter": 0,
                "chain": "REJECT-LOG",
                "packet_counter": 0
            },
            ...
        ]
    }

    """

    def parse_content(self, content):
        self.chains = []
        self.rules = []
        current_table = None
        for line in get_active_lines(content):
            if line.startswith("*"):
                current_table = line[1:].strip()
            elif line.startswith(":"):
                name, policy, counter = line[1:].split()
                packet_counter, byte_counter = counter.strip("[]").split(":")
                self.chains.append({
                    "policy": policy if policy != "-" else None,
                    "table": current_table,
                    "name": name,
                    "packet_counter": int(packet_counter),
                    "byte_counter": int(byte_counter),
                })
            elif line.startswith("-"):
                chain_name, rule = line[3:].split(None, 1)
                target_option = "-j" if "-j" in rule else "-g"
                constraints, target = [i.strip() for i in rule.split(target_option)]
                if " " in target:
                    target, target_options = target.split(None, 1)
                else:
                    target_options = None
                self.rules.append({
                    "table": current_table,
                    "chain": chain_name,
                    "rule": rule,
                    "target_action": "jump" if target_option == "-j" else "goto",
                    "constraints": constraints,

                    "target": target,
                    "target_options": target_options
                })

    def get_chain(self, name, table="filter"):
        """
        Returns the list of rules for a particular chain.
        Chain order is kept intact.
        """
        return [r for r in self.rules if r["table"] == table and r["chain"] == name]

    def get_table(self, name="filter"):
        """
        Returns the list of chains for a particular table.
        """
        return [c for c in self.chains if c["table"] == name]

    def table_chains(self, table="filter"):
        """
        Returns a dict where the keys are all the chains for the given table
        and each value is the set of rules defined for the given chain.
        """
        return {c["name"]: self.get_chain(c["name"], table) for c in self.get_table(table)}

    def get_rule(self, s):
        """
        Retuns the list of rules that contain the given string.
        """
        return [r for r in self.rules if s in r["rule"]]

    def __contains__(self, s):
        return any(s in r["rule"] for r in self.rules)
